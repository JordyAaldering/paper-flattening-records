\section{Single assignment C}\label{sec:sac}

Since we use the functional array language Single~assignment~C (SaC)~\cite{sac,sac2} as implementation vehicle for our proposed flattening,
we provide a quick overview of the key features that we use throughout the paper.
For a more in-depth introduction we refer the reader to papers such as~\cite{sac,sac2} or the online material available on \url{https://sac-home.org/docs:main}.

SaC combines a syntax very close to the imperative language C with a purely
side-effect-free semantics. This is achieved by the addition of multi-dimensional, immutable arrays to the language core, paired with an exclusion of pointers.

\subsection{Arrays in SaC}

Arrays in SaC are multi-dimensional; each array has a dimensionality (also referred to as \textit{rank}) and a \textit{shape} which describes the legal index-space of the array.
This enables computations on multi-dimensional arrays to inspect and
manipulate not only the data of an array but also its rank and shape.
Table~\ref{tab:array} shows a few examples for arrays in SaC. The left-most column provides
an abstract / mathematical representation, the middle column contains a corresponding definition in SaC and in the right column we see the three conceptual components of these arrays: their rank (an integer value), their shape (a vector of natural numbers), and their data (a vector of the values of the array).

\begin{table}[ht!]
    \newcommand{\repr}[3]{%
        \begin{tabular}{ll}
            rank:  & #1   \\
            shape: & [#2] \\
            data:  & [#3]
        \end{tabular}\vspace{2pt}\\\hline\noalign{\vskip 2pt}}
    \centering
    \begin{tabular}{c@{\hskip 1em}c@{\hskip 1em}l}\hline\noalign{\vskip 2pt}
        $\begin{pmatrix}
            1 & 2 & 3 \\
            4 & 5 & 6 \\
            7 & 8 & 9
        \end{pmatrix}$
            & \texttt{[[1,2,3], [4,5,6], [7,8,9]]}
            & \repr{2}{3,3}{1,2,3,4,5,6,7,8,9}
        $\begin{pmatrix}
            1, & 2, & 3, & -4, & -5
        \end{pmatrix}$
            & \texttt{[1,2,3,-4,-5]}
            & \repr{1}{5}{1,2,3,-4,-5}
        $\begin{pmatrix}\begin{pmatrix}
            true, & false, & true
        \end{pmatrix}\end{pmatrix}$
            & \texttt{[[true, false, true]]}
            & \repr{2}{1,3}{true,false,true}
        0.5
            & \texttt{0.5}
            & \repr{0}{\,}{0.5}
    \end{tabular}
    \caption{Array representation in SaC}
    \label{tab:array}
\end{table}

\noindent
From this table, we can observe that all elements of any given array ultimately can be represented as a \textit{flat} data vector in memory.
While the SaC syntax in the middle column may suggest to the programmer that some arrays indeed are nested, in fact, they are not; in SaC, nesting inherently is indistinguishable from higher-dimensional arrays.
This contrasts starkly with the idea of arrays prevalent in most non-array languages, where arrays are considered inherently one dimensional and where higher dimensional arrays are mimicked through nesting.
As a consequence of SaC's choice to support higher-dimensional arrays in combination with a vector for representing the shape, nested notations in SaC are restricted to the homogeneous case, i.e. all inner expressions must have the same shape.
An expression of the form \texttt{[[1],\,[2,3]]} is not admissible in SaC.

\subsection{Tensor Comprehensions}

The key language construct of SaC for defining arrays from other arrays is the \textit{Tensor Comprehension}~\cite{sac-tensor,sac-scan}.
A tensor comprehension is essentially a mapping of index vectors to values.
For example, the tensor comprehension
%
\begin{lstlisting}
{ iv -> arr[iv] * 2  |  iv < shape(arr) }
\end{lstlisting}
%
defines an array of the same shape as array \texttt{arr}, whose value in each index position \texttt{iv} equates to twice the value of \texttt{arr} at the given position.
Note here that the index variable \texttt{iv} denotes an index vector with as many elements as the array \texttt{arr} has dimensions.
The ability to express such operations that operate on arrays of arbitrary rank is referred to as \textit{rank polymorphism}.
If a fixed rank is expected, an explicit vector of indices can be used instead.
For example,
%
\begin{lstlisting}
{ [i,j] -> mat[j,i]  |  [i,j] < reverse(shape(mat)) }
\end{lstlisting}
%
transposes the two dimensional array \texttt{mat}.
Despite having a fixed-rank index space, this tensor comprehension can be turned into a rank polymorphic operation by a small change into
%
\begin{lstlisting}
{ [i,j] -> mat[j,i]  |  [i,j] < reverse(take([2], shape(mat))) }
\end{lstlisting}
%
The rank polymorphism of this expression is achieved through two measures.
Firstly, selections in SaC select entire subarrays if there are fewer indices than the rank of the array to be selected from.
Secondly, the specification of the upper bound through \texttt{reverse(take([2], shape(mat)))} ensures a two element vector as upper bound, even if the rank of the array \texttt{mat} is higher than 2.

\subsection{Function Definitions, Types, and Type Patterns}

Function definition in SaC look like their C counterparts.
The main difference is the types that are supported in SaC.
All types in SaC consist of an element type followed by a shape specification.
If the shape specification is omitted, scalar arrays are expected.
For example, the simple transpose can be defined as:
%
\begin{lstlisting}
double[n,m] transpose(double[m,n] mat)
{
    return { [i,j] -> mat[j,i]  |  [i,j] < reverse(shape(mat)) };
}
\end{lstlisting}
%
Note here that the shape variables \texttt{m} and \texttt{n} define scalar integer values that can be referred to in the function body.
This allows for a specification of the upper bound as \texttt{[n,m]} instead of \texttt{reverse(shape(mat))}.
%
\begin{lstlisting}
double[n,m] transpose(double[m,n] mat)
{
    return { [i,j] -> mat[j,i]  |  [i,j] < [n,m] };
}
\end{lstlisting}
%
The dual use of shape variables for describing domain constraints as well as for capturing these values are referred to as \textit{type patterns}~\cite{sac-typepattern}.
